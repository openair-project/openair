% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_correlation.R
\name{plot_correlation}
\alias{plot_correlation}
\title{Plot a correlation matrix with conditioning}
\usage{
plot_correlation(
  data,
  pollutant = NULL,
  type = "default",
  cluster = TRUE,
  method = "pearson",
  use = "pairwise.complete.obs",
  annotate = c("cor", "signif", "stars", "none"),
  triangle = c("all", "lower", "upper"),
  diagonal = TRUE,
  discretise = NULL,
  scale_col = c(-1, 1),
  cols = "PRGn",
  cols_annotation = "black",
  auto_text = TRUE,
  facet_opts = openair::facet_opts(),
  plot = TRUE,
  ...
)
}
\arguments{
\item{data}{A data frame.}

\item{pollutant}{If \code{NULL}, all numeric columns in \code{data} will be correlated
with one another. \code{pollutant}, as in other \code{openair} functions, may also be
a vector of column names to use instead.}

\item{type}{The column(s) of \code{data} to use to split the plot into separate
facets, passed to \code{\link[=cutData]{cutData()}}. \code{type} may be \code{NULL} or a vector with
maximum length 2, which creates a 2D grid of plots.}

\item{cluster}{Should the data be ordered according to cluster analysis? If
\code{TRUE} hierarchical clustering is applied to the correlation matrices using
\code{hclust} to group similar variables together.}

\item{method}{The correlation method to use. Can be \code{"pearson"}, \code{"spearman"}
or \code{"kendall"}.}

\item{use}{How to handle missing values in the \code{cor} function. The default is
\code{"pairwise.complete.obs"}. Care should be taken with the choice of how to
handle missing data when considering pair-wise correlations.}

\item{annotate}{What to annotate each correlation tile with. One of:
\itemize{
\item \code{"cor"}, the correlation coefficient to 2 decimal places.
\item \code{"signif"}, an X marker if the correlation is significant.
\item \code{"stars"}, standard significance stars.
\item \code{"none"}, no annotation.
}}

\item{triangle}{One of \code{"all"} (to show the complete matrix), \code{"lower"} (to
show the bottom triangle) or \code{"upper"} (to show the upper triangle).}

\item{diagonal}{When \code{TRUE}, the 'diagonal' of the plot (where the
correlation is always \code{1}) will be shown. \code{FALSE} removes this.}

\item{discretise}{Options to discretise the continuous scale into discrete
bins. Providing an integer will split the scale into that number of
bins. Alternatively, \code{\link[=disc_breaks]{disc_breaks()}} allows for extensive
customisation (e.g., defining specific bin widths, breaks, labels, and so
on).}

\item{scale_col}{Options for the colour scale of the plot. If a single
number, this will set an upper scale limit. If greater than one number, the
range of the input will be used as the axis limits. Can also be
\code{\link[=scale_opts]{scale_opts()}}, which permit further customisation such as setting axis
breaks, labels and scale transforms. Note that these options will not apply
if \code{discretise} is used, as this overrides the continuous scale.}

\item{cols}{The colour palette to use. See \code{\link[=openColours]{openColours()}}. Note that, by
default, \code{\link[=plot_correlation]{plot_correlation()}} fixes the colour scale between \code{-1} and \code{1},
so a 'diverging' palette is recommended.}

\item{cols_annotation}{The colour to use to colour text annotations. If two
colours are defined, the first will be used for positive correlations and
the second for negative correlations.}

\item{auto_text}{Perform automatic text formatting on common character
strings? \code{TRUE} will automatically, for example, subscript the 'x' in NOx
in axis labels. \code{FALSE} will leave text unchanged, but users may refine it
with, e.g., \code{\link[ggplot2:labs]{ggplot2::labs()}} or \code{\link[ggplot2:guides]{ggplot2::guides()}}.}

\item{facet_opts}{A list of options to help control how 'facets' (different
panels accessed through \code{type}) behave, e.g., whether different panels
should share the same scales. Use \code{\link[=facet_opts]{facet_opts()}} as a convenient way to
provide all necessary options.}

\item{plot}{Should a plot be produced? \code{FALSE} will instead return the
plotting data, and can be useful when analysing data to extract plot
components and plotting them in other ways.}

\item{...}{Passed to \code{\link[=cutData]{cutData()}}.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function calculates and visualises correlation matrices between air
quality pollutants (or any other numeric variables). The primary purpose is
as a tool for exploratory data analysis. Hierarchical clustering is used to
group variables that are most similar to one another, if \code{cluster = TRUE}.
It is also possible to use the \code{openair} type option to condition the data
in many flexible ways.
}
\section{Controlling scales}{


In \code{openair}, a 'scale' is anything expressed in a numeric or date range.
This includes axes and colour bars. Most \code{openair} plotting functions
possess arguments in the pattern \verb{scale_*} to control these - e.g.,
\code{scale_x}, \code{scale_y}, and \code{scale_col}.

If these arguments are passed a single number, this will set the maximum of
the scale to be that number. If two numbers are provided, these will be
used as the scale range.

\if{html}{\out{<div class="sourceCode">}}\preformatted{# x axis goes up to 100
plot_xy_scatter(mydata, "nox", "no2", scale_x = 100)

# x axis is between 50 and 150
plot_xy_scatter(mydata, "nox", "no2", scale_x = c(50, 150))
}\if{html}{\out{</div>}}

These \verb{scale_*} options can also be provided with the \code{\link[=scale_opts]{scale_opts()}}
function, which allows for further customisation, such as:
\itemize{
\item Where to add major axis/legend breaks, and how to label them.
\item Whether to transform the scale (e.g., a log or sqrt transform).
\item Where to place the axis, and whether to draw a second one (axes only).
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{plot_xy_scatter(
  mydata,
  "nox",
  "no2",
  scale_x = scale_opts(
    transform = "pseudo_log",
    breaks = c(1, 3, 10, 30, 100, 300, 1000, 3000),
    sec.axis = ggplot2::sec_axis(~.)
  )
)
}\if{html}{\out{</div>}}

Take care with date scales (e.g., \code{scale_x} in \code{\link[=plot_trend_bars]{plot_trend_bars()}});
\code{limits} should be provided as POSIXct objects. This is likely to be
refined in future. Note that, for date scales, \code{date_breaks} and
\code{date_labels} can be used to more easily refine the appearance of the
scale.
}

\section{Conditioning with \code{type}}{


Many \code{openair} plotting functions can be conditioned by using the \code{type}
argument. This splits a single plot into a grid of smaller plots,
popularised under the name "small multiples" by Edward Tufte and more
recently referred to as "faceting" (e.g., in \code{\link[ggplot2:facet_wrap]{ggplot2::facet_wrap()}}).
\code{type} is always passed to \code{\link[=cutData]{cutData()}}, meaning various presets like
\code{"year"} or \code{"month"} can be used, and numeric variables are automatically
binned.

If a single \code{type} is given, the default behaviour is for each panel to
wrap into a roughly square grid. If two \code{type}s are given, the first will
be used for the rows of the resulting grid and the second for the columns.

Not all plots can take two \code{type}s. This is usually because one facet
dimension is already reserved for the specific plot type. For example, in
\code{\link[=plot_calendar]{plot_calendar()}}, the plot is always faceted by \code{"month"} even if \code{type = NULL}.

\if{html}{\out{<div class="sourceCode">}}\preformatted{# one type (square 2D grid)
plot_heatmap(mydata, "no2", type = "year")

# two types (two 'axes' of types)
plot_heatmap(mydata, "no2", type = c("o3", "weekend"))
}\if{html}{\out{</div>}}

Functions with \code{type} also possess the \code{facet_opts} argument, which takes
the \code{\link[=facet_opts]{facet_opts()}} function. This allows for finer control of how faceting
works. This includes:
\itemize{
\item The number of rows/columns when only one \code{type} has been given.
\item Whether axes should share the same x/y limits, or if each panel should
have unique scales.
\item If scales are free, whether each panel should have a different size
proportional to their scales.
\item On which side of the plot where the facet labels should be drawn.
\item Whether all axes and axis labels should be drawn, or whether they should
only be drawn on the margins.
}

Note that not all options will apply to all plots. For example, plots on a
polar axis always have fixed x-axes that are mapped to the compass
directions.

\if{html}{\out{<div class="sourceCode">}}\preformatted{plot_heatmap(
  mydata,
  "no2",
  type = "year",
  facet_opts = facet_opts(nrow = 2, axes = "all_y", strip.position = "right")
)
}\if{html}{\out{</div>}}
}

\examples{
# basic corrgram plot
plot_correlation(mydata)

# plot by season ... and so on
plot_correlation(mydata, type = "season")

# recover dendrogram when cluster = TRUE and plot it
res <- plot_correlation(mydata, plot = FALSE)
plot(res$hclust)

\dontrun{
# more interesting are hydrocarbon measurements
hc <- importAURN(site = "my1", year = 2005, hc = TRUE)

# now it is possible to see the hydrocarbons that behave most
# similarly to one another
plot_correlation(hc, annotate = "none", cols = "Spectral")
}
}
\seealso{
The legacy \code{\link[=corPlot]{corPlot()}} function.
}
\author{
Jack Davison
}
